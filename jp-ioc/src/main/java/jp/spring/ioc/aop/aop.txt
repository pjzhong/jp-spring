使用AopProxy将Advisor（Interceptor）和JoinPoint(MethodExecution)织在一起（结合在一起）
然后Pointcut来决定哪些JoinPoint需要被Advise（Interceptor）
至于如何决定，则分别用它的手下ClassFilter和MethodMatcher决定
Advisor(Interceptor) 将由用户编写！！！
************************************************************************
在这个AOP，作者将要被Advised的对象封装到TargetSource中。这个类包含了对象的类，和一个实例。
为了以后的方便，作者也为了方便为其提供了一个助手类名为AdviseSupport, 此类包含一个Advisor, TargetSource, 和MethodMatcher.
*************************************************************************
PointCut是一个接口，它是用来表示哪些JoinPoint(methodExecution)应该被Advise(Interceptor).
它目前(2016-12-26)有一个子类，名为 AspectExpressionPointcut. 它的工作就是决定哪些oinPoint(MethodExecution)符合要求
至于哪些目标符合要求，由用户提供的AspectJ Expression决定

这里还有一个与 AspectExpressionPointcut 名字非常相像的类 AspectExpressionPointcutAdvisor(实现了PointAdvisor) 至于这个类的工作是辅助还是管理呢？
它可以的事情大概是  get和set一个Advice. 获取一个Pointcut还可以设置此Pointcut的expression.

就我目前的分析来看，两个都有，因为PointcutAdvisor是用来连接Advisor(Intercept)和Pointcut的.

它的主要工作就整合用户所提供的AspectExpression和Advisor(Interceptor)来，然后来创建Pointcut
最后使用这个Pointcut来决定JoinPoint
*************************************************************************
至于如何将Aop融合到Spring, 这里引入一个BeanPostProcessor接口，这个接口将被加入到BeanFactory中。
当Bean初始化的时候 BeanFactory将会在Bean建立完成之后，调用每一个BeanPostProcessor对Bean进行额外加工
BeanPostProcessor有一个实现了它的子类——AspectAwareAdvisorAutoProxyCreator
AspectAwareAdvisorAutoProxyCreator的工作就是，被放入BeanFactory后，在Bean创建之后对其织入(weave)

不过有一个前提就是，BeanFactory管理着任何PointcutAdvisor.
然后用此Pointcut来判定给定Bean的Class是否符合用户提供AspectJ表达式
符合了，就创建一个AdviseSupport(也一个简单的封装类，就是把各类资源整合到一起)
把PointcutAdvisor包含的Advice(MethodInterceptor)和MatchMatcher封装到AdviseSupport.
然后在将bean封装到TargetSource里面，然后到AdvisedSupport.

然后利用AdvisedSupport创建一个AopProxy(实际为 JdkDynamicAopProxy).来完成最后一部织入

