beanDefinition保存着要创建的对象基本信息，其包含目标对象的Class和其实列
PropertyValue用来来保存需注入到Bean中的Property的名字和值
PropertyValues其实就是一个对PropertyValue非常简单的封装，这里不祥说。不懂可以去看看

bean的Property是另一个对象怎么办，Spring使用BeanReference来解决，其保存了所需要的对象的ID
**********************************************************************************
但是怎么读取BeanDefinition呢？
具体负责读取BeanDefinition都放在IO里面
这里作者使用了Xml来定义BeanDefinition

具体分层为Resource, ResourceLoader, ResourceReader
怎样的ResourceLoader就会载入其相对类型的Resource,
使用ResourceLoader载入了Resource, 资源是有了。
但要怎么用呢，这时候就要用到对应的ResourceReader,它会负责解析已经载入的Resource.
然后来生成BeanDefinition

********************************************************************************

好了，现在BeanDefinition有了，怎么载入和解析BeanDefinition也有了............

beanDefinition的基本作用就是保存bean的基本信息，然后用这些来创建。
至于怎么创建，总不可能直接new吧，不然写如此多代码有什么用呢......
所以作者把Bean的创建工作都交给了Factory

BeanFactory（接口）
AbstractBeanFactory（抽象类，使用了模板模式来规定创建一个的流程）
........ （子类，实现了bean具体创建过程可能还包含了属性的注入）

*****************************************************************************
这里还有一个BeanPostProcessor。ioc容器在初始化自身和创建bean时对外暴露的接口，
主要用于连接其它模块
****************************************************************************
ApplicationContext存在的意义就是：
0.读取配置文件
1.扫描Class,
2.从Class中解析BeanDefinition
3.创建BeanFactory或者用户提供一个
4.将BeanDefinition注册到BeanFactory里面去
5.初始化环境(载入beanPostProcess等)....
6.获取bean
......
把这些步骤全部封装到ApplicationContext，然后外部环境只需要跟ApplicationContext打交道就行了
****************************************************************************
我在原作者的基础上增加了自动装配的功能。为此我新添加了几个类，在此做一下记录防止以后自己回来都看不懂了。
   1.InjectField——用来封装被@Autowired标记的成员变量，其会被放在BeanDefinition里面，将在Bean创建的时候调用，
   2.AnnotationBeanDefinitionReader——专门用户读取被@Component标记的类，并将其解释成合适的BeanDefinition
并对AutowireCapableBeanFactory进行了一些，让其支持自动装配